<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Batch Correction</title>

    <style>
        body {
            margin: 0;
            min-height: 100vh;
            font-family: Arial, sans-serif;

            background-image: url("/static/background_images/correction.png");
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;

            display: flex;
            justify-content: center;
            align-items: center;
        }

        .top-buttons {
            width: 100%;
            max-width: 1200px;
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .top-buttons button {
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }

        .top-buttons button:hover {
            background-color: #2980b9;
        }

        .page-container {
            width: 100%;
            max-width: 1200px;
            padding: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: white;
            text-shadow: 1px 1px 4px black;
            margin-bottom: 20px;
        }

        .image-row {
            display: flex;
            justify-content: center; /* centers the row horizontally */
            gap: 30px;
            margin-bottom: 20px;
        }

        #image-container {
            position: relative;
            display: flex;
            justify-content: center; /* centers canvas and image horizontally */
            align-items: center;     /* centers vertically if container is taller */
            margin: 0 auto;
        }

        #image-container img {
            display: block;
            max-width: 100%;
            border-radius: 6px;
            border: 2px solid #ddd;
        }

        #overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        h3 {
            text-align: center;
            color: white;
            text-shadow: 1px 1px 3px black;
        }

        .bbox {
            position: absolute;
            border: 2px dashed;
            pointer-events: none;
        }

        .bbox.chip { border-color: #00ff00; }
        .bbox.void { border-color: #ff3333; }

        .toolbar {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        select, button {
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
        }

        button {
            background: #3498db;
            color: white;
        }

        button:hover {
            background: #2980b9;
        }

        button:disabled {
            background: #aaa;
            cursor: not-allowed;
        }

        #progress {
            margin-top: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
        }

        #finish-btn {
            background-color: #8e44ad; /* Purple */
        }

        #finish-btn:hover {
            background-color: #732d91;
        }
    </style>
</head>

<body>
<div class="page-container">

    <h1>Batch Correction</h1>

    <!-- Top Buttons -->
    <div class="top-buttons">
        <button onclick="window.location.href='/'">Run New Prediction</button>
        <button onclick="goToBatchResults()">Back to Batch Results</button>
    </div>


    <div class="image-row" id="image-section">
        <div>
            <h3>Model Prediction (click to correct errors)</h3>
            <div id="image-container">
                <img id="image">
                <canvas id="overlay-canvas"></canvas>
            </div>
        </div>  
    </div>

    <p id="instruction-text" style="color:white;">
        Click and drag to draw bounding boxes
    </p>

    <div class="toolbar" id="toolbar">
        <select id="class_id">
            <option value="0">Chip</option>
            <option value="1">Void</option>
        </select>

        <button id="undo-btn" disabled>Undo</button>
        <button id="submit-btn">Submit Image</button>
    </div>

    <div id="completion-section" style="display:none; text-align:center;">
        <h2 style="color:white; text-shadow:1px 1px 4px black;">
            Batch review completed
        </h2>

        <button id="finish-btn" style="font-size:18px; padding:12px 28px;">
            Proceed to Retraining
        </button>
    </div>

    <p id="progress"></p>

</div>

<script>
let batchResults = {{ results|tojson }};
let currentIndex = 0;
let boxes = [];          // all boxes for current image
let undoStack = [];      // only for user-added boxes
let updates = [];

const img = document.getElementById("image");
const canvas = document.getElementById("overlay-canvas");
const ctx = canvas.getContext("2d");

const undoBtn = document.getElementById("undo-btn");
const submitBtn = document.getElementById("submit-btn");
const finishBtn = document.getElementById("finish-btn");
const classSelect = document.getElementById("class_id");
const progressText = document.getElementById("progress");

let firstPoint = null;

// Adjust canvas size when image loads
img.onload = () => {
    canvas.width = img.width;
    canvas.height = img.height;
    redrawBoxes();
};

// Get mouse position relative to canvas
function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

// Load image and populate boxes
function loadImage(index) {
    if (index >= batchResults.length) {
        document.getElementById("image-section").style.display = "none";
        document.getElementById("toolbar").style.display = "none";
        document.getElementById("instruction-text").style.display = "none";
        progressText.style.display = "none";
        document.getElementById("completion-section").style.display = "block";
        return;
    }

    const item = batchResults[index];
    img.src = item.image_url;

    boxes = [];
    undoStack = [];

    // Convert model-predicted boxes into editable=false boxes
    item.chips?.forEach(chip => boxes.push({ bbox: chip.bbox, class_id: 0, editable: false }));
    item.voids?.forEach(voidBox => boxes.push({ bbox: voidBox.bbox, class_id: 1, editable: false }));

    redrawBoxes();

    progressText.textContent = `Image ${index + 1} of ${batchResults.length}: ${item.filename}`;
}

// Draw a single box on canvas
function drawBox(bbox, class_id) {
    const scaleX = canvas.width / img.naturalWidth;
    const scaleY = canvas.height / img.naturalHeight;
    const x1 = bbox[0] * scaleX;
    const y1 = bbox[1] * scaleY;
    const x2 = bbox[2] * scaleX;
    const y2 = bbox[3] * scaleY;

    ctx.strokeStyle = class_id === 0 ? "red" : "yellow";
    ctx.lineWidth = 2;
    ctx.setLineDash([6]);
    ctx.strokeRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
}

let mode = 'add'; // 'add' or 'delete'

// Add a toggle button
const toolbar = document.getElementById("toolbar");
const modeBtn = document.createElement("button");
modeBtn.textContent = "Switch to Delete Mode";
modeBtn.onclick = () => {
    if (mode === 'add') {
        mode = 'delete';
        modeBtn.textContent = "Switch to Add Mode";
    } else {
        mode = 'add';
        modeBtn.textContent = "Switch to Delete Mode";
    }
};
toolbar.insertBefore(modeBtn, undoBtn);

// Redraw all boxes
function redrawBoxes() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    boxes.forEach(b => drawBox(b.bbox, b.class_id));
}

// Canvas click logic
canvas.onclick = (e) => {
    const pos = getMousePos(e);
    const scaleX = img.naturalWidth / canvas.width;
    const scaleY = img.naturalHeight / canvas.height;

    if (mode === 'delete') {
        for (let i = boxes.length - 1; i >= 0; i--) {
            const b = boxes[i];
            const x1 = b.bbox[0] / scaleX;
            const y1 = b.bbox[1] / scaleY;
            const x2 = b.bbox[2] / scaleX;
            const y2 = b.bbox[3] / scaleY;

            if (pos.x >= Math.min(x1, x2) && pos.x <= Math.max(x1, x2) &&
                pos.y >= Math.min(y1, y2) && pos.y <= Math.max(y1, y2)) {
                
                // mark as deleted in undoStack if you want undo
                undoStack.push(b);
                boxes.splice(i, 1);
                redrawBoxes();
                undoBtn.disabled = undoStack.length === 0;
                return;
            }
        }
    } else {
        // Add box logic
        if (!firstPoint) {
            firstPoint = pos;
            return;
        }

        const secondPoint = pos;
        const bbox = [
            firstPoint.x * scaleX,
            firstPoint.y * scaleY,
            secondPoint.x * scaleX,
            secondPoint.y * scaleY
        ];

        const newBox = { bbox, class_id: parseInt(classSelect.value), editable: true };
        boxes.push(newBox);

        undoStack.push({ ...newBox, added: true }); // mark as user-added
        firstPoint = null;
        redrawBoxes();
        undoBtn.disabled = false;
    }
};

// Undo last user-added box
undoBtn.onclick = () => {
    if (!undoStack.length) return;
    const box = undoStack.pop();

    if (box.added) {
        // Remove user-added box by matching bbox and class_id
        boxes = boxes.filter(b => 
            !(b.editable && b.class_id === box.class_id &&
              b.bbox[0] === box.bbox[0] && b.bbox[1] === box.bbox[1] &&
              b.bbox[2] === box.bbox[2] && b.bbox[3] === box.bbox[3])
        );
    } else {
        // Restore deleted box
        boxes.push(box);
    }

    redrawBoxes();
    undoBtn.disabled = undoStack.length === 0;
};

// Submit current corrections
submitBtn.onclick = () => {
    const item = batchResults[currentIndex];
    const allBoxes = boxes.map(b => ({
        bbox: b.bbox,
        class_id: b.class_id,
        type: b.class_id === 0 ? "chip" : "void"
    }));

    updates.push({
        image_id: item.image_id,
        status: "final",
        correction: { chips: allBoxes }
    });

    loadImage(++currentIndex);
};

// Finish batch and send updates to server
finishBtn.onclick = async () => {
    const batchId = batchResults[0].batch_id;

    const res = await fetch(`/correct/batch/${batchId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ updates })
    });

    if (!res.ok) {
        alert("Failed to save corrections");
        return;
    }

    // Redirect to admin page (retraining will be triggered there)
    window.location.href = "/admin";
};

loadImage(currentIndex);

// Go back to batch results
function goToBatchResults() {
    if (batchResults.length > 0) {
        const batchId = batchResults[0].batch_id;
        window.location.href = `/results/batch/${batchId}`;
    } else {
        alert("No batch data available.");
    }
}
</script>

</body>
</html>
